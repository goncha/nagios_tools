#!/usr/bin/env python
"""
This takes a recipient email address and a graphite URL and sends a
POST to <graphite host>/dashboard/email with a body that looks like
this:

    sender=user%40example.com&recipients=user2%40example.com&subject=foo&message=bar&graph_params=%7B%22target%22%3A%22target%3DdrawAsInfinite(metric.path.in.graphite)%22%2C%22from%22%3A%22-2hours%22%2C%22until%22%3A%22now%22%2C%22width%22%3A600%2C%22height%22%3A250%7D

...which will cause the graphite installation to send an email.

This script will also ping graphite so that you can
actually graph when these notifications were sent out as events, and
layer those graphs on top of the graphs that correspond to the notification
event, so we can visually verify that the alerts are going out (or attempted),
and that it's happening at the right time, etc.

Note that the pingback functionality sends the events to a metric in graphite
named 'nagios.<metricname>'.

"""
import requests
import logging
from logging.handlers import SysLogHandler
from socket import socket
import time
import sys
from email.mime.image import MIMEImage
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import smtplib
from optparse import OptionParser


CARBON_SERVER = 'host.name.fqdn'
CARBON_PORT = 2003


## Use syslog to output log message
logger = logging.getLogger("sendgraph")
logger.setLevel(logging.INFO)
#logger.addHandler(logging.StreamHandler())
logger.addHandler(SysLogHandler(address='/dev/log'))


def send_graph_email(graph, subject, sender, recipients, body=None):
    """
    Builds an email with the attached graph.

    :param body: Text portion of the alert notification email.
    :param graph: Assumed to be a PNG, currently.
    :param subject: Email subject line
    :param sender: an email address
    :param receivers: list of email addresses to send to.
    :return:
    """
    logger.debug("body: %s  subject: %s  sender: %s  recipients: %s" % (body, subject, sender, recipients))
    if body is None:
        body = '\n'

    msg = MIMEMultipart()
    msg.attach(MIMEText(body))

    imgpart = MIMEImage(graph, _subtype='png')
    imgpart.add_header('Content-Disposition', 'attachment', filename='graph.png')
    msg.attach(imgpart)

    msg['to'] = ', '.join(recipients)
    msg['from'] = sender
    msg['subject'] = subject
    s = smtplib.SMTP()
    try:
        s.connect()
        s.sendmail(sender, recipients, msg.as_string())
        s.close()
    except Exception as out:
        logger.error("Sending mail failed: %s" % out)

def ping_graphite(metric_name):
    sock = socket()
    try:
        sock.connect( (CARBON_SERVER,CARBON_PORT) )
    except:
        print "Couldn't connect to %(server)s on port %(port)d, is carbon-agent.py running?" % { 'server':CARBON_SERVER, 'port':CARBON_PORT }
        sys.exit(1)

    now = time.time()
    message = '%s %s %s\n' % (metric_name, '1.0', now)
    try:
        sock.sendall(message)
    except Exception as out:
        logger.error("Updating graphite failed: %s", out)
        sys.exit(1)

    logger.info("Updated graphite: %s", message)

def do_options():
    parser = OptionParser('Usage: %prog [options] recipients')
    parser.add_option('-u', '--url',
                      action='store',
                      dest='graph_url',
                      help="URL to the graphite graph that spawned the nagios alert")
    parser.add_option('-s', '--subject',
                      action='store',
                      dest='subject',
                      help='The subject of sending mail.')
    return parser.parse_args()

def main():
    options, args = do_options()
    graph_url = options.graph_url
    subject = options.subject
    recipients = args
    logger.debug('graph url is %s' % graph_url)
    graph = requests.get(graph_url)
    logger.debug("Response headers for graph request: %s", graph.headers)
    body = sys.stdin.read()
    sender = 'nagios-graphite'
    send_graph_email(graph.content, subject, sender, recipients, body)


if __name__ == '__main__':
    main()


# Local Variables: **
# comment-column: 56 **
# indent-tabs-mode: nil **
# python-indent: 4 **
# End: **
